#!/usr/bin/python
# -*- coding: utf-8 -*-

import re

import c_ast

import clang
from clang.cindex import CursorKind, TypeKind


# A function show(level, *args) would have been simpler but less fun
# and you'd need a separate parameter for the AST walkers if you want
# it to be exchangeable.
class Level(int):
    '''represent currently visited level of a tree'''

    def show(self, *args):
        '''pretty print an indented line'''
        # print '\t'*self + ' '.join(map(str, args))

    def __add__(self, inc):
        '''increase level'''
        return Level(super(Level, self).__add__(inc))


def MAKE_NAME(name):
    """ Converts a mangled C++ name to a valid python identifier.

    """
    name = name.replace('$', 'DOLLAR')
    name = name.replace('.', 'DOT')
    if name.startswith('__'):
        return '_X' + name
    elif name[0] in '01234567879':
        return '_' + name
    return name


WORDPAT = re.compile('^[a-zA-Z_][a-zA-Z0-9_]*$')


def CHECK_NAME(name):
    """ Checks if `name` is a valid Python identifier. Returns
    `name` on success, None on failure.

    """
    if WORDPAT.match(name):
        return name
    return None


class ClangParser(object):
    """ Parses source file into a list of file-level c_ast nodes.

    """
    # cursor element types that have subelements.

    # For example, 
    # function arguments are subelements of a function, but struct 
    # fields are their own toplevel xml elements

    ##TODO
    #has_subelements = set(['Enumeration', 'Function', 'FunctionType',
    #                       'OperatorFunction', 'Method', 'Constructor',
    #                       'Destructor', 'OperatorMethod'])

    def __init__(self, *args):
        # `context` acts like stack where parent nodes are pushed
        # before visiting children
        self.context = []

        # `all` maps the unique ids from the xml to the c_ast
        # node that was generated by the element. This is used
        # after all nodes have been generated to go back and
        # hook up dependent nodes.
        self.all = {}

        ## collected nodes in parse order
        #self.nodes = []

        # XXX - what does this do?
        self.cpp_data = {}

        # `cdata` is used as temporary storage while elements
        # are being processed.
        self.cdata = None

        # `cvs_revision` stores the gccxml version in use.
        self.cvs_revision = None

    #--------------------------------------------------------------------------
    # Parsing entry points
    #--------------------------------------------------------------------------
    def parse(self, cfile, include_dirs, language, unsaved_files=None):
        """ Parsing entry point. `cfile` is a filename or a file
        object.

        """
        args_include_dirs = ['-I' + d for d in include_dirs]
        args_language = ['-x' + language if language else '']

        index = clang.cindex.Index.create()
        tu = index.parse(cfile,
                         args=args_include_dirs + args_language,
                         #args = ['-I/usr/include/c++/4.2.1',],
                         options=clang.cindex.TranslationUnit.PARSE_INCOMPLETE + \
                                 clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD + \
                                 clang.cindex.TranslationUnit.PARSE_SKIP_FUNCTION_BODIES,
                         unsaved_files=unsaved_files
        )

        for d in tu.diagnostics:
            self.print_diag_info(d)

        #UGLY: first element is TRANSLATION_UNIT, parse children
        self.parse_element(tu.cursor)
        #for c in tu.cursor.get_children():
        #    self.parse_element(c)


    def print_diag_info(self, diag):
        print 'category name:', diag.category_name
        print 'location:', diag.location.file, diag.location.line, ':', diag.location.column
        print 'severity:', diag.severity
        print 'spelling:', diag.spelling
        #print 'ranges:', list(diag.ranges)
        #print 'fixits', list(diag.fixits)
        print 'fixits', ['%d:%d-%d:%d %s' % (f.range.start.line, f.range.start.column,
                                             f.range.end.line, f.range.end.column,
                                             f.value) for f in diag.fixits]
        print


    simple_types = {TypeKind.VOID: 'void',
                    TypeKind.BOOL: 'bint',
                    TypeKind.CHAR_U: 'char',
                    TypeKind.UCHAR: 'unsigned char',  #TODO unsigned? char????
                    #TypeKind.CHAR16 = TypeKind(6)
                    #TypeKind.CHAR32 = TypeKind(7)
                    TypeKind.USHORT: 'unsigned short',
                    TypeKind.UINT: 'unsigned int',
                    TypeKind.ULONG: 'unsigned long',
                    TypeKind.ULONGLONG: 'unsigned long long',
                    #TypeKind.UINT128: TypeKind(12)
                    TypeKind.CHAR_S: 'char',  #signed char on platforms where it is default
                    TypeKind.SCHAR: 'signed char',
                    TypeKind.WCHAR: 'char',  #TODO: ???
                    TypeKind.SHORT: 'short',
                    TypeKind.INT: 'int',
                    TypeKind.LONG: 'long',
                    TypeKind.LONGLONG: 'long long',
                    #TypeKind.INT128: TypeKind(20)
                    TypeKind.FLOAT: 'float',
                    TypeKind.DOUBLE: 'double',
                    TypeKind.LONGDOUBLE: 'long double',
    }

    def type_to_c_ast_type(self, t, level, recurse=True):
        # convert clang type to c_ast type, return c_ast and hash value for corresponding cursor (or None)
        level.show('in type to c_ast:', 'kind:', t.kind, repr(t.get_declaration().spelling))

        kind = t.kind
        if kind in self.simple_types:
            const = t.is_const_qualified()
            volatile = t.is_volatile_qualified()
            fundtype = c_ast.FundamentalType(self.simple_types[kind])
            return c_ast.CvQualifiedType(fundtype, const, volatile), None

        elif kind is TypeKind.CONSTANTARRAY:
            a, foo = self.type_to_c_ast_type(t.element_type, level + 1)
            return c_ast.ArrayType(a, 0, t.element_count - 1), None

        elif kind is TypeKind.TYPEDEF:
            const = t.is_const_qualified()
            volatile = t.is_volatile_qualified()
            fundtype = c_ast.FundamentalType(t.get_declaration().spelling)
            return c_ast.CvQualifiedType(fundtype, const, volatile), None

        elif kind is TypeKind.POINTER:
            const = t.is_const_qualified()
            volatile = t.is_volatile_qualified()
            ptrtype, foo = self.type_to_c_ast_type(t.get_pointee(), level + 1)
            if ptrtype is not None:
                ptrtype = c_ast.PointerType(ptrtype, None, None)
                return c_ast.CvQualifiedType(ptrtype, const, volatile), None

        elif kind is TypeKind.LVALUEREFERENCE:
            reftype, foo = self.type_to_c_ast_type(t.get_pointee(), level + 1)
            if reftype is not None:
                return c_ast.RefType(reftype), None

        elif kind is TypeKind.ENUM:
            #see if declaration already parsed
            typ = self.all.get(t.get_declaration().hash)
            if typ is not None:
                return typ, t.get_declaration().hash
            else:
                level.show('enum declaration not yet parsed')
                typ = self.parse_element(t.get_declaration(), level)  #TODO ????
                return typ, t.get_declaration().hash

        elif kind is TypeKind.FUNCTIONPROTO:
            level.show('return type:')
            returntype, id_ = self.type_to_c_ast_type(t.get_result(), level + 1)
            #TODO: very similar to visit_FUNCTION_DECL
            functype = c_ast.FunctionType(returntype, None)
            level.show('argument types:')
            for arg in t.argument_types():
                #TODO: argument name?
                functype.add_argument(c_ast.Argument('', self.type_to_c_ast_type(arg, level + 1)[0]))
            return functype, None

        elif kind is TypeKind.UNEXPOSED and recurse:
            return self.type_to_c_ast_type(t.get_canonical(), level + 1, recurse=False)

        else:
            level.show('do not know to handle type kind, search for declaration')
            typ = self.all.get(t.get_declaration().hash)

            #print 'in type_to_c_ast_type:'
            #print 'parsed type', typ
            #print

            if typ is not None:
                return typ, t.get_declaration().hash
            else:
                level.show("can't find declaration for type, parse type declaration", kind, t.get_declaration().kind)
                #print
                typ = self.parse_element(t.get_declaration(), level + 1)
                if typ is not None:
                    return typ, t.get_declaration().hash
                else:
                    #raise Exception 
                    if kind is TypeKind.UNEXPOSED:
                        return c_ast.FundamentalType('unexposed_type'), None

                    level.show('give up, unknown_type')
                    return c_ast.FundamentalType('unknown_type'), None  #TODO: fixme

    def parse_element(self, cursor, level=Level()):
        #level.show('file:', repr(cursor.location.file))
        # ignore builtin nodes
        if cursor.location.file is None and cursor.kind is not CursorKind.TRANSLATION_UNIT:
            return

        # Find and call visitor
        mth = getattr(self, 'visit_' + cursor.kind.name, None)
        if mth is not None:
            result = mth(cursor, level)
        else:
            result = self.unhandled_element(cursor, level)

        # Record the result and register the the id, which is
        # used in the _fixup_* methods. Some elements don't have
        # an id, so we create our own.
        if result is not None:
            location = cursor.location
            if location.file is not None:
                result.location = (location.file.name, location.line)

            self.all[cursor.hash] = result

        #debug output
        if result is not None:
            level.show('cursor:', cursor.kind, str(cursor.type.kind))
            level.show('name:', repr(result.name))
            print


        # if this element has subelements, push it onto the context
        # since the next elements will be it's children.
        if cursor.kind in [
            #CursorKind.MACRO_DEFINITION,
            CursorKind.TRANSLATION_UNIT,
            CursorKind.NAMESPACE,
            CursorKind.ENUM_DECL,
            CursorKind.STRUCT_DECL,
            CursorKind.UNION_DECL,
            CursorKind.CLASS_DECL,
            CursorKind.CLASS_TEMPLATE,
            CursorKind.FUNCTION_TEMPLATE,
            CursorKind.FIELD_DECL,
            CursorKind.PARM_DECL,
            CursorKind.CONSTRUCTOR,
            CursorKind.CXX_METHOD,
            # Functions handle their children (arguments) themselves and
            # not using the standard way of parsing. This make sense as
            # it can quite complex for function pointers (where some
            # arguments belong to the function declaration, some to the
            # function prototype).
            #CursorKind.FUNCTION_DECL,
        ]:
            self.context.append(result)

            for c in cursor.get_children():
                child = self.parse_element(c, level + 1)
                if child is not None and hasattr(result, 'add_child'):
                    result.add_child(child)

            # if this element has subelements, then it will have
            # been push onto the stack and needs to be removed.
            self.context.pop()

        self.cdata = None
        return result


    def unhandled_element(self, cursor, level):
        """ Handler for element nodes where a real handler is not
         found.

        """
        if cursor.location.file is None:
            return
        level.show('unhandled element', repr(cursor.spelling), repr(cursor.displayname), cursor.kind)

    #--------------------------------------------------------------------------
    # Ignored elements and do-nothing handlers
    #--------------------------------------------------------------------------
    def visit_Ignored(self, attrs):
        """ Ignored elements are those which we don't care about,
        but need to keep in place because we care about their 
        children.

        """
        name = attrs.get('name', None)
        if name is None:
            name = attrs.get('mangled', None)
            if name is None:
                name = 'UNDEFINED'
            else:
                name = MAKE_NAME(name)
        return c_ast.Ignored(name)

    visit_Method = visit_Ignored
    visit_Constructor = visit_Ignored
    visit_Destructor = visit_Ignored
    visit_OperatorMethod = visit_Ignored
    visit_Base = visit_Ignored
    visit_Converter = visit_Ignored
    visit_MethodType = visit_Ignored
    visit_Ellipsis = lambda *args: None

    visit_OffsetType = visit_Ignored

    #--------------------------------------------------------------------------
    # Node element handlers
    #--------------------------------------------------------------------------
    def visit_TRANSLATION_UNIT(self, cursor, level):
        container = c_ast.File(cursor.displayname)
        self.context.append(container)
        return container

    def visit_NAMESPACE(self, cursor, level):
        return c_ast.Namespace(cursor.spelling)

    def visit_TYPEDEF_DECL(self, cursor, level):
        c_ast_type, id_ = self.type_to_c_ast_type(cursor.underlying_typedef_type, level)
        if c_ast_type is not None:
            level.show('in visit_TYPEDEF_DECL, c_ast_type =', c_ast_type.__class__.__name__, 'name =',
                       repr(c_ast_type.name))

            #special handling of typedef enum, struct, union
            if type(c_ast_type) in (c_ast.Enumeration, c_ast.Union, c_ast.Struct):
                # If the underlying typedef type doesn't have a name, add a
                # new field called `typedef_name` with the name of the typedef.
                # This happens e.g. when there's a struct that doesn't
                # contain a tag name. Having a name is needed for proper
                # flattening
                c_ast_type.typedef_name = cursor.spelling

                if not c_ast_type.name:
                    # unnamed record -> remove declaration from self.all
                    level.show('remove declaration', c_ast_type, self.all[id_])
                    try:
                        idx = c_ast_type.context.members.index(c_ast_type)
                        level.show('remove from parent, idx', idx)
                        c_ast_type.context.members.pop(idx)
                    except ValueError:
                        level.show("not contained in parent", c_ast_type)

                elif c_ast_type.name == cursor.spelling:
                    #enum tagname == typename: no typedef, do nothing
                    return

            return c_ast.Typedef(cursor.spelling, c_ast_type, None)

    def visit_STRUCT_DECL(self, cursor, level):
        name = cursor.spelling
        s = c_ast.Struct(name, context=self.context[-1], members=[])
        return s

    def visit_UNION_DECL(self, cursor, level):
        name = cursor.spelling
        return c_ast.Union(name, context=self.context[-1])

    def visit_FIELD_DECL(self, cursor, level):
        # If a field has struct as a child, use the field name as the
        # structs name (in case it hasn't one). This way anonymous structs
        # and unions get a proper mangled name for Cython.
        children = list(cursor.get_children())
        if len(children) == 1 and children[0].kind in \
                [CursorKind.STRUCT_DECL, CursorKind.UNION_DECL]:
            node = self.all[children[0].hash]
            if not node.name:
                node.name = cursor.spelling
        parent = self.context[-1]
        name = cursor.spelling
        c_ast_type, id_ = self.type_to_c_ast_type(cursor.type, level)
        member = c_ast.Field(name, c_ast_type, context=parent)
        return member

    def visit_ENUM_DECL(self, cursor, level):
        name = cursor.spelling
        return c_ast.Enumeration(name, self.context[-1])

    def visit_ENUM_CONSTANT_DECL(self, cursor, level):
        name = cursor.spelling
        value = cursor.enum_value
        return c_ast.EnumValue(name, value)

    def visit_FUNCTION_DECL(self, cursor, level):
        name = cursor.spelling
        returntype, id_ = self.type_to_c_ast_type(cursor.type.get_result(), level)
        func = c_ast.Function(name, returntype)
        for arg in cursor.get_arguments():
            level.show('function argument', arg.kind, arg.spelling)
            func.add_argument(c_ast.Argument(arg.spelling, self.type_to_c_ast_type(arg.type, level + 1)[0]))
        return func

    visit_CXX_METHOD = visit_FUNCTION_DECL
    visit_CONSTRUCTOR = visit_FUNCTION_DECL

    def visit_VAR_DECL(self, cursor, level):
        name = cursor.spelling
        typ, id_ = self.type_to_c_ast_type(cursor.type, level)
        return c_ast.Variable(name, typ, None, None)

    def visit_CLASS_DECL(self, cursor, level):
        c = c_ast.Class(cursor.spelling, context=self.context[-1])
        return c

    def visit_CLASS_TEMPLATE(self, cursor, level):
        c = c_ast.Class(cursor.spelling, context=self.context[-1])
        return c

    visit_FUNCTION_TEMPLATE = visit_FUNCTION_DECL

    def visit_PARM_DECL(self, cursor, level):
        name = cursor.spelling
        parent = self.context[-1]
        typ, id_ = self.type_to_c_ast_type(cursor.type, level)
        arg = c_ast.Argument(name, typ)
        #parent.add_argument(arg)
        return arg

    def repair_type(self, obj, name):
        #repair type of c_ast object
        if isinstance(obj, c_ast.FundamentalType):
            obj.name = name
        elif isinstance(obj, (c_ast.Field, c_ast.PointerType, c_ast.ArrayType, c_ast.RefType, c_ast.Argument)):
            self.repair_type(obj.typ, name)
        elif isinstance(obj, (c_ast.Function, c_ast.FunctionType, c_ast.OperatorFunction)):
            self.repair_type(obj.returns, name)

    def visit_TYPE_REF(self, cursor, level):
        typ, id = self.type_to_c_ast_type(cursor.type, level)
        parent = self.context[-1]
        if parent is not None:
            level.show('TYPE REF', repr(cursor.displayname), 'parent: %s, type: %s' % (parent, cursor.type.kind))

            if cursor.type.kind is TypeKind.UNEXPOSED:
                #fix type of parent
                self.repair_type(parent, cursor.displayname)

    def visit_TEMPLATE_TYPE_PARAMETER(self, cursor, level):
        param = cursor.spelling
        parent = self.context[-1]
        if hasattr(parent, 'add_template_parameter'):
            parent.add_template_parameter(param)
        else:
            level.show('TEMPLATE_TYPE_PARAMETER: unknown parent', parent)

    def visit_Namespace(self, attrs):
        name = attrs['name']
        members = attrs['members'].split()
        return c_ast.Namespace(name, members)

    def visit_File(self, attrs):
        name = attrs['name']
        return c_ast.File(name)

    def visit_Variable(self, attrs):
        name = attrs['name']
        typ = attrs['type']
        context = attrs['context']
        init = attrs.get('init', None)
        return c_ast.Variable(name, typ, context, init)

    def visit_PointerType(self, attrs):
        typ = attrs['type']
        size = attrs['size']
        align = attrs['align']
        return c_ast.PointerType(typ, size, align)

    visit_ReferenceType = visit_PointerType

    def visit_ArrayType(self, attrs):
        # min, max are the min and max array indices
        typ = attrs['type']
        min = attrs['min']
        max = attrs['max']
        if max == 'ffffffffffffffff':
            max = '-1'
        if max == '':  #ADDED gregor
            max = '-1'
        min = int(min.rstrip('lu'))
        max = int(max.rstrip('lu'))
        return c_ast.ArrayType(typ, min, max)

    def visit_CvQualifiedType(self, attrs):
        typ = attrs['type']
        const = attrs.get('const', None)
        volatile = attrs.get('volatile', None)
        return c_ast.CvQualifiedType(typ, const, volatile)

    def visit_Function(self, attrs):
        name = attrs['name']
        returns = attrs['returns']
        context = attrs['context']
        attributes = attrs.get('attributes', '').split()
        extern = attrs.get('extern')
        return c_ast.Function(name, returns, context, attributes, extern)

    def visit_FunctionType(self, attrs):
        returns = attrs['returns']
        attributes = attrs.get('attributes', '').split()
        return c_ast.FunctionType(returns, attributes)

    def visit_OperatorFunction(self, attrs):
        name = attrs['name']
        returns = attrs['returns']
        context = attrs['context']
        attributes = attrs.get('attributes', '').split()
        extern = attrs.get('extern')
        #return c_ast.OperatorFunction(name, returns)
        return c_ast.OperatorFunction(name, returns, context, attributes, extern)

    def visit_Argument(self, attrs):
        parent = self.context[-1]
        if parent is not None:
            typ = attrs['type']
            name = attrs.get('name')
            arg = c_ast.Argument(typ, name)
            parent.add_argument(arg)

    def visit_Enumeration(self, attrs):
        # If the name isn't a valid Python identifier, 
        # create an unnamed enum
        name = CHECK_NAME(attrs['name'])
        size = attrs['size']
        align = attrs['align']
        return c_ast.Enumeration(name, size, align)

    def visit_EnumValue(self, attrs):
        parent = self.context[-1]
        if parent is not None:
            name = attrs['name']
            value = attrs['init']
            val = c_ast.EnumValue(name, value)
            parent.add_value(val)

    def visit_Struct(self, attrs):
        name = attrs.get('name')
        if name is None:
            name = MAKE_NAME(attrs['mangled'])
        bases = attrs.get('bases', '').split()
        members = attrs.get('members', '').split()
        context = attrs['context']
        align = attrs['align']
        size = attrs.get('size')
        return c_ast.Struct(name, align, members, context, bases, size)

    def visit_Class(self, attrs):
        name = attrs.get('name')
        if name is None:
            name = MAKE_NAME(attrs['mangled'])
        bases = attrs.get('bases', '').split()
        #fix 'protected:_12345'
        bases = [b.replace('protected:', '') for b in bases]
        members = attrs.get('members', '').split()
        context = attrs['context']
        align = attrs['align']
        size = attrs.get('size')
        return c_ast.Struct(name, align, members, context, bases, size)  #TODO: Class

    def visit_Union(self, attrs):
        name = attrs.get('name')
        if name is None:
            name = MAKE_NAME(attrs['mangled'])
        bases = attrs.get('bases', '').split()
        members = attrs.get('members', '').split()
        context = attrs['context']
        align = attrs['align']
        size = attrs.get('size')
        return c_ast.Union(name, align, members, context, bases, size)

    def visit_Field(self, attrs):
        name = attrs['name']
        typ = attrs['type']
        context = attrs['context']
        bits = attrs.get('bits', None)
        offset = attrs.get('offset')
        return c_ast.Field(name, typ, context, bits, offset)

    #--------------------------------------------------------------------------
    # Post parsing helpers
    #--------------------------------------------------------------------------
    def get_macros(self, text):
        """ Attempts to extract the macros from a piece of text
        and converts it to a Macro node containing the name,
        args, and body.  

        """
        if text is None:
            return

        # join and split so we can accept a list or  string. 
        text = ''.join(text)
        for m in text.splitlines():
            name, body = m.split(None, 1)
            name, args = name.split('(', 1)
            args = '(%s' % args
            self.all[name] = c_ast.Macro(name, args, body)

    def get_aliases(self, text, namespace):
        """ Attemps to extract defined aliases of the form
        #define A B and store them in an Alias node.

        """
        if text is None:
            return

        aliases = {}
        text = ''.join(text)
        for a in text.splitlines():
            name, value = a.split(None, 1)
            a = c_ast.Alias(name, value)
            aliases[name] = a
            self.all[name] = a

        # The alias value will be located in the namespace,
        # or the aliases. Otherwise, it's unfound.
        for name, a in aliases.items():
            value = a.value
            if value in namespace:
                a.typ = namespace[value]
            elif value in aliases:
                a.typ = aliases[value]
            else:
                pass

    def get_result(self):
        """ After parsing, call this method to retrieve the results
        as a list of AST nodes. This list will contain *all* nodes
        in the xml file which will include a bunch of builtin and 
        internal stuff that you wont want.

        """

        # Gather any macros.
        self.get_macros(self.cpp_data.get('functions'))
        interesting = (c_ast.Typedef, c_ast.Struct, c_ast.Enumeration,
                       c_ast.Union, c_ast.Function, c_ast.Variable,
                       c_ast.Namespace, c_ast.File,
                       c_ast.Class,
        )

        result = []
        namespace = {}
        for node in self.all.values():
            if not isinstance(node, interesting):
                continue
            name = getattr(node, 'name', None)
            if name is not None:
                namespace[name] = node
            result.append(node)
        self.get_aliases(self.cpp_data.get('aliases'), namespace)

        return result


# `cfile` can be a 2-tuple with a virtual file name and the file contents.
# The contents can either be a string or a file-like object (with a read()
# method).
def parse(cfile, include_dirs, language):
    parser = ClangParser()
    if isinstance(cfile, list):
        parser.parse(cfile[0][0], include_dirs, language, unsaved_files=cfile)
    else:
        parser.parse(cfile, include_dirs, language)
    items = parser.get_result()
    return items
